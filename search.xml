<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux文件分发脚本，只需一条命令将你的文件分发到各个服务器上</title>
      <link href="/shell001/d585266bb763/"/>
      <url>/shell001/d585266bb763/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在运维或在日常工作生活中，我们经常会把一个文件拷贝到其它服务器上，或同时分发到多个服务器上，甚至要求目标机将文件放在相同的路径下，方便程序进一步调用。 </p><p>遇到这种问题，我们通常的做法是使用scp或rsync命令把文件拷贝一个一个地拷贝到多台服务器上，这样做费时费力；大神的做法是使用ansible的playbook一下把事情干完，前提是你得会ansible；快捷的做法就是使用今天的脚本了。</p><h1 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h1><p>目前拥有4台机器，分别为client、node1、node2和node3，client与其它3台机器能够建立ssh链接。在client的/root/test目录下有a.txt和b.txt两个文件。</p><p><img src="01.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@client test]# ls /root/test/</span><br><span class="line">a.txt  b.txt</span><br><span class="line">[root@client test]# </span><br></pre></td></tr></table></figure><p>我把文件分发到node1、node2和node3的/root/test下，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在/root/test目录下执行, xrsync是我的脚本</span><br><span class="line">[root@client test]# xrsync a.txt b.txt </span><br></pre></td></tr></table></figure><p>执行分发过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@client test]# xrsync a.txt b.txt </span><br><span class="line">============ node1 ============</span><br><span class="line">sending incremental file list</span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line">sent 93 bytes  received 35 bytes  256.00 bytes/sec</span><br><span class="line">total size is 2  speedup is 0.02</span><br><span class="line">sending incremental file list</span><br><span class="line">b.txt</span><br><span class="line"></span><br><span class="line">sent 93 bytes  received 35 bytes  85.33 bytes/sec</span><br><span class="line">total size is 2  speedup is 0.02</span><br><span class="line">============ node2 ============</span><br><span class="line">sending incremental file list</span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line">sent 93 bytes  received 35 bytes  256.00 bytes/sec</span><br><span class="line">total size is 2  speedup is 0.02</span><br><span class="line">sending incremental file list</span><br><span class="line">b.txt</span><br><span class="line"></span><br><span class="line">sent 93 bytes  received 35 bytes  256.00 bytes/sec</span><br><span class="line">total size is 2  speedup is 0.02</span><br><span class="line">============ node3 ============</span><br><span class="line">sending incremental file list</span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line">sent 93 bytes  received 35 bytes  85.33 bytes/sec</span><br><span class="line">total size is 2  speedup is 0.02</span><br><span class="line">sending incremental file list</span><br><span class="line">b.txt</span><br><span class="line"></span><br><span class="line">sent 93 bytes  received 35 bytes  256.00 bytes/sec</span><br><span class="line">total size is 2  spee</span><br></pre></td></tr></table></figure><p>到node2上看一下，文件果然存在。同样地，node3和node4也同步过去了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># node2上查看</span><br><span class="line">[root@node2 ~]# ls /root/test/</span><br><span class="line">a.txt  b.txt</span><br><span class="line">[root@node2 ~]# </span><br><span class="line"></span><br><span class="line"># node3上查看</span><br><span class="line">[root@node3 ~]# ls /root/test/</span><br><span class="line">a.txt  b.txt</span><br><span class="line">[root@node3 ~]# </span><br><span class="line"></span><br><span class="line"># node4上查看</span><br><span class="line">[root@node4 ~]# ls /root/test/</span><br><span class="line">a.txt  b.txt</span><br><span class="line">[root@node4 ~]# </span><br></pre></td></tr></table></figure><h1 id="脚本奉上"><a href="#脚本奉上" class="headerlink" title="脚本奉上"></a>脚本奉上</h1><p>整个脚本的代码，只需要把其中的node1 node2 node3修改为自己环境下的主机名或ip地址即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 判断参数是否足够</span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">echo Not Enounh Arguement!</span><br><span class="line">exit;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 遍历所有的机器</span><br><span class="line">for host in node1 node2 node3</span><br><span class="line">do</span><br><span class="line">echo ============  $host ============</span><br><span class="line">for file in $@</span><br><span class="line">do</span><br><span class="line"># 判断文件是否存在</span><br><span class="line">if [ -e $file ]</span><br><span class="line">then</span><br><span class="line"># 获取父目录</span><br><span class="line">pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line"></span><br><span class="line"># 获取当前目录的名称</span><br><span class="line">fname=$(basename $file)</span><br><span class="line">ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">else</span><br><span class="line">echo $file does not exists!</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="运行条件"><a href="#运行条件" class="headerlink" title="运行条件"></a>运行条件</h1><p>为了更方便脚本的运行，建议使用如下优化。  </p><p>1.修改/etc/hosts文件，加入IP地址与主机名的对应关系，这样方便我们使用主机名直接操作。比如我演示的机器配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/hosts</span><br><span class="line"># 加入配置，自己的机器对应修改</span><br><span class="line">……</span><br><span class="line">192.168.31.47 client</span><br><span class="line">192.168.31.48 node1</span><br><span class="line">192.168.31.50 node2</span><br><span class="line">192.168.31.51 node3</span><br></pre></td></tr></table></figure><p>2.客户机与目标机之间使用ssh密码验证登录，这样在传输文件时不需要二次验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 生成ssh私钥</span><br><span class="line">ssh-keygen -f /root/.ssh/id_rsa -N &#x27;&#x27; </span><br><span class="line"># 循环把公钥传递到服务器上，免密登录</span><br><span class="line">for i in node1 node2 node3 </span><br><span class="line">do </span><br><span class="line"> ssh-copy-id $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 根据提示输入密码</span><br></pre></td></tr></table></figure><p>3.给脚本加可执行权限，并配置环境变量，使用全局可用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 把文件存储为xrsync，加上x权限</span><br><span class="line">[root@client shell]# chmod +x xrsync </span><br><span class="line">[root@client shell]# </span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line"># 我把脚本放在/opt/shell下的，自己情况类比修改</span><br><span class="line">[root@client shell]# vim /etc/profile.d/my_env.sh </span><br><span class="line">export PATH=$PATH:/opt/shell</span><br><span class="line"></span><br><span class="line"># 配置生效，就可以在全局生效了</span><br><span class="line">[root@client opt]# source /etc/profile</span><br></pre></td></tr></table></figure><p>至此，早点干完活，开始愉快的玩耍吧~</p>]]></content>
      
      
      <categories>
          
          <category> 神奇的脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用这个脚本实现Linux下的备份与增量同步</title>
      <link href="/shellscript1/1108d700c78c/"/>
      <url>/shellscript1/1108d700c78c/</url>
      
        <content type="html"><![CDATA[<p>  在运维过程中，通常有备份文件的需求，也就是把一些不能存储在数据库的文件备份到一个指定的目录。有人可能会说，使用系统的定时工具，写个脚本就好了，每隔一段时间执行一下备份任务。  </p><p>  但不失为一种方法，但我想在有数据变动的情况下才执行备份任务，没有变化的情况不执行，能否实现呢？  </p><p>  可以，在Linux下可以使用Inotify来解决。Inotify是一个 Linux特性，它监控文件系统操作，比如读取、写入和创建。Inotify 反应灵敏，用法非常简单，并且比 cron 任务的繁忙轮询高效得多，只要使用Inotify文件有变动+rsync命令同步有变化的文件，这样就达到增量备份的需求</p><h1 id="Inotify安装"><a href="#Inotify安装" class="headerlink" title="Inotify安装"></a>Inotify安装</h1>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 安装基本编译环境</span><br><span class="line"></span><br><span class="line"># Rhel &amp;&amp; CentOS</span><br><span class="line"></span><br><span class="line">sudo yum install gcc make</span><br><span class="line"></span><br><span class="line"># Ubuntu</span><br><span class="line"></span><br><span class="line">sudo apt install gcc make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下载Inotify工具</span><br><span class="line"></span><br><span class="line">sudo wget http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line"></span><br><span class="line">sudo tar -xf inotify-tools-3.14.tar.gz</span><br><span class="line"></span><br><span class="line">cd inotify-tools-3.14/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置、编译和安装</span><br><span class="line"></span><br><span class="line">sudo ./configure</span><br><span class="line"></span><br><span class="line">sudo make &amp;&amp; make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  安装完成之后会在/usr/local/bin/inotifywait下生成可执行文件, 使用以下命令时，屏幕输出正常则安装成功。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@blog ~]# inotifywait --help</span><br><span class="line"></span><br><span class="line">inotifywait 3.14</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnrvgf9jj31ba0r842j.jpg" alt="image"></p><h1 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h1><p>  inotifywait [选项] 目标文件夹</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#常用命令选项：</span><br><span class="line"></span><br><span class="line">-m,持续监控（捕获一个事件后不退出）</span><br><span class="line"></span><br><span class="line">-r,递归监控，包括子目录及文件</span><br><span class="line"></span><br><span class="line">-q,减少屏幕输出信息</span><br><span class="line"></span><br><span class="line">-e,指定监视的modify、move、create、delete、attrib等事件类别。不加此选项时，监控所有操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  来测试一下，在任一目录创建一个temp文件夹，使用inotifywait命令监控。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inotifywait -mrq temp/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  另起一个shell窗口，创建一个空文件，可以发现监控中有多种事件产生。</p><p>  <img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnrw5ze5j30z60nuac6.jpg" alt="image"></p><p>  由此可见，在对文件夹操作时，的确可以监控到时间。</p><h1 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h1><p>  脚本逻辑，当inotifywait捕获到事件时，将文件备份到指定文件夹中，基本逻辑：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while inotifywait -rq  监控文件夹</span><br><span class="line"></span><br><span class="line">  do</span><br><span class="line"></span><br><span class="line">    #重复执行同步代码</span><br><span class="line"></span><br><span class="line">  done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  比如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意rsync下的源一定要加/</span></span><br><span class="line"></span><br><span class="line">while inotifywait -rq /tmp</span><br><span class="line"></span><br><span class="line">  do </span><br><span class="line"></span><br><span class="line">    rsync --delete -a /tmp/  root@192.168.0.2:/tmp</span><br><span class="line"></span><br><span class="line">  done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  大家也可以使用-e参数，只在指定的事件下执行，或搭配其它脚本命令使用。发挥想象力吧！</p>]]></content>
      
      
      <categories>
          
          <category> 神奇的脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenEuler4</title>
      <link href="/OpenEuler4/c6a1e2597e63/"/>
      <url>/OpenEuler4/c6a1e2597e63/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenEuler3</title>
      <link href="/OpenEuler3/f0284c9127bd/"/>
      <url>/OpenEuler3/f0284c9127bd/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 好玩的项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenEuler2</title>
      <link href="/OpenEuler2/a9b821718da6/"/>
      <url>/OpenEuler2/a9b821718da6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用KVM虚拟机安装华为OpenEuler系统</title>
      <link href="/openeulerWithKvm/4c8faf3ce71b/"/>
      <url>/openeulerWithKvm/4c8faf3ce71b/</url>
      
        <content type="html"><![CDATA[<h1 id="背景和优点"><a href="#背景和优点" class="headerlink" title="背景和优点"></a>背景和优点</h1><p>KVM是Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，从名字可以看出，是一个基于内核的虚拟化系统。</p><p>相比较于我们常用的VMware虚拟机，KVM不仅仅开源，而且基于Linux内核，其工作效率更高，这点在红帽官方得到证实。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnho1jckj31bp0u042u.jpg" alt="image"><br>下面是红帽对KVM与VMware官方作出的说明，我把地址放在下面，有需要的朋友可以参考了解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># KVM与VMware官方对比说明</span><br><span class="line">https://www.redhat.com/zh/topics/virtualization/kvm-vs-vmware-comparison</span><br></pre></td></tr></table></figure><p>KVM 和 VMware ESXi 都是非常成熟稳定的虚拟机监控程序，可以支持各种企业工作负载，由于KVM其开源特性，你不用再像ESXi那样为其支付许可费用，更能节约成本。</p><h1 id="安装KVM"><a href="#安装KVM" class="headerlink" title="安装KVM"></a>安装KVM</h1><p>我这里依然在CentOS下搭建演示，使用Ubuntu的朋友操作类似。<br>使用root用户登录到系统，使用以下命令安装KVM核心组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用命令安装以下KVM核心组件</span><br><span class="line">yum -y install qemu-kvm</span><br><span class="line">yum -y install libvirt-daemon</span><br><span class="line">yum -y install libvirt-client</span><br><span class="line">yum -y install libvirt-daemon-driver-qemu</span><br><span class="line">yum -y install virt-manager</span><br></pre></td></tr></table></figure><p>上面各个组件的含义可参考下表：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhiytpsj313y0duwg7.jpg" alt="image"><br>安装完成后，启动libvirtd并设置为开机启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now libvirtd</span><br><span class="line">systemctl status libvirtd</span><br></pre></td></tr></table></figure><p>可以看到本机上的libvirtd守护进程已经在正常运行。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhi30vzj31em0jkadb.jpg" alt="image"></p><h1 id="使用KVM图形工具"><a href="#使用KVM图形工具" class="headerlink" title="使用KVM图形工具"></a>使用KVM图形工具</h1><p>如果你的Linux有图形桌面环境，那你可能需要到桌面上去执行启动KVM图形管理工具；如果你像我一样使用的是字符下的Linux系统，根本没有安装桌面，那需要一个图形转发软件来显示图形。<br>比如使用NETSARANG旗下的XManager软件来转发，也就是同Xshell一家的软件。<br>在Windows下安装好XManager和Xshell工具软件，使用Xshell登录到前面安装好KVM的操作系统，使用以下命令运行KVM图形管理工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-manager</span><br></pre></td></tr></table></figure><p>执行后，会自动弹出一个窗口，如果你像我一样没有报错则成功。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhjcgbtj30vq0g4abb.jpg" alt="image"></p><h1 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h1><p>利用文件传输工具将OpenEuler传输到服务器/tmp目录下备用。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhnln6rj30rz0ftdiv.jpg" alt="QQ20211123-0"><br>回到前面的图形操作界面，在KVM里新建一个虚拟机。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhlssupj30g50bx3yv.jpg" alt="1"><br>选择本地的ISO镜像文件。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhn7obfj30bd0b4t98.jpg" alt="2"><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhjt6xij30e80b4jru.jpg" alt="3"><br>选择本地的ISO文件，并浏览本地目录。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhlcivrj30kt0eqmxu.jpg" alt="4"><br>定位到文件目录/tmp下，并选定我们的安装镜像文件中。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhkuvfkj30uh0lcmyo.jpg" alt="5"><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhifg07j30uf0dq3zm.jpg" alt="6"><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhka8b3j30e80b4gm6.jpg" alt="7"></p><p>配置好内存和磁盘和CPU大小。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhh8opqj30b40b474l.jpg" alt="8"><br>重命名下新建的虚拟机，点击完成。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhhhe5fj30b40b4q3e.jpg" alt="9"></p><p>最后就是我们熟悉的安装界面了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhmmxraj30mh0hrjs2.jpg" alt="10"><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsnhm6401j30m60heq61.jpg" alt="11"></p>]]></content>
      
      
      <categories>
          
          <category> Linux涨姿势 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenEuler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/test/30c55125f534/"/>
      <url>/test/30c55125f534/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>等一等，我有话要说！</title>
      <link href="/firstPage/9bfdde7b1759/"/>
      <url>/firstPage/9bfdde7b1759/</url>
      
        <content type="html"><![CDATA[<h1 id="建站说明"><a href="#建站说明" class="headerlink" title="建站说明"></a>建站说明</h1><p>本站点是为了方便个人写作而建立，亦是为了记录工作和生活中的经验和心得，与遗忘做斗争。同时为了方便广大网友友好交流技术与资源共享，因此在访问本网站时，务必文明发言！！！</p><p>如您提问或留言，请留下准确的联系方式，方便有效联系，不浪费彼此宝贵的人生。</p>]]></content>
      
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> myThink </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
